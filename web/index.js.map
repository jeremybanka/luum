{
  "version": 3,
  "sources": ["../src/constants/index.ts", "../src/constants/filters.ts", "../src/constants/schemes.ts", "../src/export/channelsToHex.ts", "../src/utils/clamp.ts", "../src/utils/interpolate.ts", "../src/utils/wrapAround.ts", "../src/import/hueToRelativeChannels.ts", "../src/solveFor/hueFromChannels.ts", "../src/solveFor/lumFromChannels.ts", "../src/solveFor/maxSatForHueInFilter.ts", "../src/solveFor/satFromChannels.ts", "../src/solveFor/specificLumFromHue.ts", "../src/export/specToChannelsFixLimit.ts", "../src/export/specToHexFixLimit.ts", "../src/export/specToHex.ts", "../src/identify/hue.ts", "../src/import/channelsToSpec.ts", "../src/import/normalizeHex.ts", "../src/import/hexToChannels.ts", "../src/import/hexToSpec.ts", "../src/mixers/contrast.ts", "../src/mixers/hue.ts", "../src/mixers/lum.ts", "../src/mixers/sat.ts", "../src/mixers/index.ts", "../src/scheme/export.ts", "../src/constants/spec.ts", "../src/utils/mapObject.ts", "../src/scheme/import.ts"],
  "sourcesContent": ["export const HUE_STRUCTURES = {\n  none: [],\n  polar: [180],\n  split: [150, 210],\n  trine: [120, 240],\n  square: [90, 180, 270],\n}\nexport const CHANNEL_SPECIFIC_LUM = {\n  R: 0.3,\n  G: 0.5,\n  B: 0.2,\n}\n/*\nconst I'M_WONDERING_IF_THIS_IS_NOT_VERY_ACCURATE = {\n  R: 0.2126,\n  G: 0.7152,\n  B: 0.0722,\n}\n*/\n", "import type { Filter } from \"~\"\n\nexport const unfiltered: Filter = [\n  { sat: 255, hue: 0 },\n  { sat: 255, hue: 360 },\n]\nexport const CMYK: Filter = [\n  { sat: 255, hue: 55 },\n  { sat: 127, hue: 120 },\n  { sat: 255, hue: 200 },\n  { sat: 255, hue: 205 },\n  { sat: 170, hue: 240 },\n  { sat: 230, hue: 270 },\n  { sat: 210, hue: 300 },\n  { sat: 255, hue: 320 },\n]\n", "export const UI = {\n  state: {\n    hover: {},\n    active: {},\n    disabled: {},\n  },\n  bg: {\n    shade: 24,\n    state: {\n      base: {},\n      hover: { shade: 18 },\n      active: { shade: 32 },\n      disabled: { shade: 32 },\n    },\n  },\n  mg: {\n    shade: 48,\n  },\n  fg: {\n    contrast: `soft`,\n    state: {\n      hover: { contrast: `harden` },\n      active: { contrast: `harden` },\n      disabled: { shade: 20 },\n    },\n  },\n}\n\n// Example:\n/* ```\n[\n  [<component-name>, {\n    'rootColor': [],\n    'variables': [],\n    'children': [<recurse>]\n  }],\n  []\n]\n\n// transforms: shade, tint, contrast, sat, lum, hue\n\n```\n*/\n\nexport const trifactory = {\n  PaletteModule: {\n    contextColor: [{ resetColor: `#fee` }, { shade: 20 }],\n    /*\n    // NOTE: These state changes are localized to the current\n    // object, and have no impact on children.\n    states: {\n      hover: [{tint: 10}, {shade: 22}],\n    },\n    */\n    // NOTE: these variables get included into each child\n    // as ex-<variable-name>\n    variables: {\n      bg: [],\n      mg: [{ resetColor: 1 }, { shade: 10 }],\n      fg: [{ contrast: `soft` }],\n    },\n    children: {\n      Control: {\n        // NOTE: All these colors start with the contextColor\n        // and not with the ex-color from parent\n        states: {\n          base: {},\n          hover: [{ tint: 12 }],\n          active: [{ shade: 18 }],\n        },\n        variables: {\n          bg: [{ shade: 24 }],\n          mg: [{ shade: 48 }],\n          fg: {\n            // NOTE: All these colors start with a context of the\n            // existing state of the parent.\n            states: {\n              base: [{ shade: 24 }, { contrast: `soft` }],\n              hover: [{ shade: 24 }, { contrast: `soft` }],\n              active: [{ shade: 24 }, { contrast: `hard` }],\n            },\n          },\n        },\n      },\n    },\n  },\n}\n\n// color scheme  ->           = CSS stylesheet\n// color palette -> component = CSS scope\n// color element -> role      = CSS variable\n// color state   ->             CSS pseudo-class\n\n// factored ops -> nested hex lists -> compiled form (CSS)\n// scheme       -> palette set      -> package\n\n// ops\n// _ PaletteName   // use\n// _ transformation\n// _ input > state\n// _ el\n\n/* scheme\n\n*/\n\n// palettes\nexport const palettes = [\n  {\n    id: `PaletteName`,\n    hex: `#f00`,\n    states: [\n      {\n        id: `base`,\n        hex: `#f00`,\n        elements: [\n          { id: `bg`, hex: `#f00` },\n          { id: `mg`, hex: `#f00` },\n          { id: `fg`, hex: `#f00` },\n        ],\n      },\n      {\n        id: `hover`,\n        hex: `#f00`,\n        elements: [\n          { id: `bg`, hex: `#f00` },\n          { id: `mg`, hex: `#f00` },\n          { id: `fg`, hex: `#f00` },\n        ],\n      },\n    ],\n  },\n]\n\n/*\nconst colorSchema = {\n  exfg: colorContext.softContrast,\n  exbg: hex,\n  fg: {\n    base: colorContext.softContrast,\n    hover: colorContext.softContrast,\n    active: colorContext.hardContrast,\n    disable: a,\n  },\n  mg: [20, 15, 25].map(n => shade(n)),\n  bg: [10, 5, 15].map(n => shade(n)),\n}\n\nconst stylesheet = `\na\n`\n*/\n", "import type { ChannelObject, Hex } from \"~\"\n\nconst channelsToHex = (channels: ChannelObject): Hex =>\n  `#${Object.values(channels)\n    .map((channel) => {\n      let channelHex = channel.toString(16)\n      if (channelHex.length === 1) channelHex = 0 + channelHex\n      return channelHex\n    })\n    .join(``)}`\n\nexport default channelsToHex\n", "type Clamp = (value: number, [min, max]: [number, number]) => number\n\nconst clamp: Clamp = (value, [min, max]) =>\n  value > max ? max : value < min ? min : value\n\nexport default clamp\n", "import type { Fraction } from \"~\"\n\ntype Interpolate = (args: {\n  completionRatio: Fraction\n  range: [to: number, from: number]\n}) => number\n\nconst interpolate: Interpolate = ({\n  completionRatio = 0.5,\n  range: [to, from],\n}) => {\n  const value = from + completionRatio * (to - from)\n  /*\n  console.log('||| to', to, 'from', from)\n  console.log(\"||| completionRatio\", completionRatio)\n  console.log(\"||| value\", value)\n  */\n  return value\n}\n\nexport default interpolate\n", "const wrapAround = (value: number, [min, max]: [number, number]): number => {\n  const range = max - min\n  while (value >= max) value -= range\n  while (value < min) value += range\n  return value\n}\n\nexport default wrapAround\n", "import type { Degree, Fraction } from \"~\"\n\nimport { wrapAround } from \"../utils\"\n\n/*eslint-disable max-len */\n/**\n * Gives us the relative values of the channels,\n * irrespective of the white light beneath them.\n * @param {number} hue - in degrees. Gets safely wrapped around first thing.\n *\n * Digital Red      0 ->   0\n *\n * Sunlight         50 ->  50\n *\n * Digital Yellow   60 ->  60\n *\n * Citron           70 ->  70\n *\n * Turquoise        510 -> 150\n *\n * @const {number} hueReduced - hue 0-359.9 is now a floating point 0-5.999.\n *\n * Digital Red    0 ->   0  ~  0.000\n *\n * Sunlight       50 -> 5/6  ~  0.833\n *\n * Digital Yellow 60 ->   1  ~  1.000\n *\n * Citron         70 -> 7/6  ~  1.167\n *\n * Turquoise      150 -> 5/2  ~  2.500\n *\n * @const {number} hueInteger - from 1-6. Tells us what color region we are in.\n *\n * Digital Red    0.000 -> 0\n *                : red-into-yellow region\n *\n * Sunlight       0.833 -> 0\n *                : red-into-yellow region\n *\n * Digital Yellow 1.000 -> 1\n *                : yellow-into-green region\n *\n * Citron         1.167 -> 1\n *                : yellow-into-green region\n *\n * Turquoise      2.500 -> 2\n *                : green-into-cyan region\n *\n * hueInteger is the 'whole number' piece of hueReduced.\n * FYI, the six color regions are bounded by red, yellow, green, cyan, blue, magenta.\n *\n * @const {number} hueDecimal - tells where we are in this region.\n *\n * Digital Red    0.000 -> 0.000\n *                : at the very beginning\n *\n * Sunlight       0.833 -> 0.833\n *                : near the end\n *\n * Digital Yellow 1.000 -> 0.000\n *                : at the very beginning\n *\n * Citron         1.167 -> 0.167\n *                : near the beginning\n *\n * Turquoise      2.500 -> 0.500\n *                : at the halfway point\n *\n * hueDecimal is the 'fraction' piece of hueReduced.\n * we are going to use this number to determine the value of the in-between channel.\n *\n * @const {number} x - used in primary-secondary transitions like Red into Yellow\n * @const {number} y - used in secondary-primary transitions like Yellow into Green\n * To understand the function of x and y, take the difference between\n *\n * Sunlight       (hue 50),\n * Citron         (hue 70),\n * Digital Yellow (hue 60),\n *\n * as an instructive case. These colors are all basically yellow.\n *\n * Sunlight is hue 50, which puts it near the end of the red-into-yellow region.\n *\n * This means its Red channel is full, and its Green channel is almost full.\n * The fullness of its Green channel is directly proportional to its\n * hueDecimal, the distance from the beginning of this region: 0.833\n *\n * Citron is hue 70, which puts it near the beginning of the yellow-into-green region.\n *\n * This means its Red channel is ALMOST FULL, and its Green channel is FULL.\n * So the fullness of its Red channel is INVERSELY proportional to its\n * hueDecimal, the distance from the beginning of this region: 1 - 0.167 = 0.833\n *\n * Digital Yellow is hue 60, which puts it at the very beginning of the yellow-into-green region.\n *\n * This means its Red Channel and its Green channel must both be full.\n * Like Citron, the fullness of Digital Yellow's Red channel is inversely proportional to its\n * hueDecimal, which is 0. Therefore Digital Yellow's Red channel has a fullness of 1.\n *\n * @returns array of values reflecting the spread between channels\n *\n * Digital Red    case 0:  [   R ===== 1       G = x = 0.000   B ===== 0      ]\n *\n * Sunlight       case 0:  [   R ===== 1       G = x = 0.833   B ===== 0      ]\n *\n * DigitalYellow  case 1:  [   R = y = 1.000   G ===== 1       B ===== 0      ]\n *\n * Citron         case 1:  [   R = y = 0.833   G ===== 1       B ===== 0      ]\n *\n * Turquoise      case 2:  [   R ===== 0       G ===== 1       B = x = 0.500  ]\n *\n * here we see detailed breakdowns of the function's final output for our running examples.\n */\n/* eslint-enable max-len */\nexport default (hue: Degree): [r: Fraction, g: Fraction, b: Fraction] => {\n  hue = wrapAround(hue, [0, 360])\n  const hueReduced = hue / 60\n  const hueInteger = Math.floor(hueReduced)\n  const hueDecimal = hueReduced - hueInteger\n  const x = hueDecimal\n  const y = 1 - hueDecimal\n  switch (hueInteger) {\n    /* eslint-disable prettier/prettier */\n    case 0: return [1, x, 0]\n    case 1: return [y, 1, 0]\n    case 2: return [0, 1, x]\n    case 3: return [0, y, 1]\n    case 4: return [x, 0, 1]\n    case 5: return [1, 0, y]\n    default: throw new Error(`invalid hue served: ${hue}`)\n    /* eslint-enable prettier/prettier */\n  }\n}\n", "import type { ChannelObject } from \"~\"\n\nconst hueFromChannels = ({ R, G, B }: ChannelObject): number => {\n  let hue = 0\n  if (R > G && G >= B) hue = 60 * (0 + (G - B) / (R - B))\n  if (G >= R && R > B) hue = 60 * (2 - (R - B) / (G - B))\n  if (G > B && B >= R) hue = 60 * (2 + (B - R) / (G - R))\n  if (B >= G && G > R) hue = 60 * (4 - (G - R) / (B - R))\n  if (B > R && R >= G) hue = 60 * (4 + (R - G) / (B - G))\n  if (R >= B && B > G) hue = 60 * (6 - (B - G) / (R - G))\n  return hue\n}\n\nexport default hueFromChannels\n", "import type { ChannelObject } from \"~\"\n\nimport { CHANNEL_SPECIFIC_LUM } from \"../constants\"\n\nconst lumFromChannels = ({ R, G, B }: ChannelObject): number => {\n  const lum =\n    (CHANNEL_SPECIFIC_LUM.R * R) / 255 +\n    (CHANNEL_SPECIFIC_LUM.G * G) / 255 +\n    (CHANNEL_SPECIFIC_LUM.B * B) / 255\n  // console.log('||| found lum', lum)\n  return lum\n}\n\nexport default lumFromChannels\n", "import type { Filter, Degree } from \"~\"\n\nimport { wrapAround } from \"../utils\"\n\nexport default (hue: Degree, filter: Filter): number => {\n  // 430\n  let maxSat = 255\n  const hueWrapped = wrapAround(hue, [0, 360]) // 70\n  for (let a = -1, b = 0; b < filter.length; a++, b++) {\n    a = wrapAround(a, [0, filter.length])\n    // console.log('||| a =', a, 'b =', b)\n    const hueDoubleWrapped =\n      a > b ? wrapAround(hueWrapped, [-180, 180]) : undefined // undef\n    const tuningPointA = filter[a]\n    const tuningPointB = filter[b]\n    const hueA =\n      a > b ? wrapAround(tuningPointA.hue, [-180, 180]) : tuningPointA.hue\n    const hueB = tuningPointB.hue\n    if (\n      (hueDoubleWrapped || hueWrapped) >= hueA &&\n      (hueDoubleWrapped || hueWrapped) < hueB\n    ) {\n      // console.log(\n      //   '||| hue', hue, 'between', tuningPointA.hue, 'and', tuningPointB.hue\n      // )\n      let $ = hueDoubleWrapped || hueWrapped // 70\n      $ -= hueA // 70 - 50 = 20 //\n      $ /= hueB - hueA // 20 / (120 - 50) = 2/7\n      $ *= tuningPointB.sat - tuningPointA.sat // -128 * 2 / 7 = -256 / 7 ~= -37\n      $ += tuningPointA.sat\n      Math.round($)\n      // console.log('||| _', _)\n      maxSat = $\n    }\n  }\n  // console.log('--- maxSat', maxSat)\n  return maxSat\n}\n", "import type { ChannelObject } from \"~\"\n\nconst satFromChannels = ({ R, G, B }: ChannelObject): number => {\n  const sat = Math.max(R, G, B) - Math.min(R, G, B)\n  // console.log('||| found sat', sat)\n  return sat\n}\n\nexport default satFromChannels\n", "import { CHANNEL_SPECIFIC_LUM } from \"../constants\"\nimport hueToRelativeChannels from \"../import/hueToRelativeChannels\"\n\nexport default (hue: number): number => {\n  const [factorR, factorG, factorB] = hueToRelativeChannels(hue)\n\n  const lumR = CHANNEL_SPECIFIC_LUM.R * factorR\n  const lumG = CHANNEL_SPECIFIC_LUM.G * factorG\n  const lumB = CHANNEL_SPECIFIC_LUM.B * factorB\n\n  const specificLum = lumR + lumG + lumB\n\n  return specificLum\n}\n", "import type {\n  ChannelObject,\n  Degree,\n  Filter,\n  Fraction,\n  LuumSpec,\n  OutOf255,\n  Range,\n} from \"~\"\n\nimport { unfiltered } from \"../constants/filters\"\nimport hueToRelativeChannels from \"../import/hueToRelativeChannels\"\nimport {\n  lumFromChannels,\n  specificLumFromHue,\n  maxSatForHueInFilter,\n} from \"../solveFor\"\nimport { clamp } from \"../utils\"\n\nconst minChannelsForSaturationFromHue = (hue: Degree) => {\n  const relativeChannels = hueToRelativeChannels(hue)\n  const channelSpreader = (trueSaturation: OutOf255): ChannelObject => {\n    const makeMinChannel = (idx: number) =>\n      Math.round(relativeChannels[idx] * trueSaturation)\n    return {\n      R: makeMinChannel(0),\n      G: makeMinChannel(1),\n      B: makeMinChannel(2),\n    }\n  }\n  return channelSpreader\n}\n\ntype IlluminationObj = {\n  minChannels: ChannelObject\n  trueLuminosity: number\n  minLum: number\n}\n\nconst channelsFromIlluminationObj = ({\n  minChannels,\n  trueLuminosity,\n  minLum,\n}: IlluminationObj): ChannelObject => {\n  const { max, round } = Math\n  const maxWhite = 255 - max(...Object.values(minChannels))\n  const white = clamp(round((trueLuminosity - minLum) * 255), [0, maxWhite])\n  const channels = {\n    R: minChannels.R + white,\n    G: minChannels.G + white,\n    B: minChannels.B + white,\n  }\n  return channels\n}\n\ntype SpecToChannelsFixLimit = (\n  spec: LuumSpec,\n  filter?: Filter\n) => {\n  channels: ChannelObject\n  fix: { sat: number; lum: number }\n  limit: { sat: Range; lum: Range }\n}\n\nconst specToChannelsFixLimit: SpecToChannelsFixLimit = (\n  { hue, sat, lum, prefer = `lum` },\n  filter = unfiltered\n) => {\n  const minChannelsForSaturation = minChannelsForSaturationFromHue(hue)\n\n  let trueSaturation: OutOf255\n  let trueLuminosity: Fraction\n  let minChannels: ChannelObject\n  let maxChannels: ChannelObject\n  let specificLum: Fraction\n  let minLum = 0\n  let maxLum = 1\n  let maxSat = maxSatForHueInFilter(hue, filter)\n\n  switch (prefer) {\n    case `sat`:\n      trueSaturation = clamp(Math.min(sat, maxSat), [0, 255])\n      minChannels = minChannelsForSaturation(trueSaturation)\n      maxChannels = {\n        R: minChannels.R + 255 - trueSaturation,\n        G: minChannels.G + 255 - trueSaturation,\n        B: minChannels.B + 255 - trueSaturation,\n      }\n      minLum = lumFromChannels(minChannels)\n      maxLum = lumFromChannels(maxChannels)\n      trueLuminosity = clamp(lum, [minLum, maxLum])\n\n      break\n    case `lum`:\n      trueLuminosity = clamp(lum, [0, 1])\n      specificLum = specificLumFromHue(hue)\n      maxSat = Math.min(\n        maxSat,\n        Math.round(\n          trueLuminosity <= specificLum\n            ? 255 * (trueLuminosity / specificLum)\n            : (255 * (1 - trueLuminosity)) / (1 - specificLum)\n        )\n      )\n      trueSaturation = Math.min(sat, maxSat)\n      minChannels = minChannelsForSaturation(trueSaturation)\n      minLum = lumFromChannels(minChannels)\n      break\n  }\n\n  const channels = channelsFromIlluminationObj({\n    minChannels,\n    trueLuminosity,\n    minLum,\n  })\n\n  return {\n    channels,\n    fix: {\n      sat: trueSaturation,\n      lum: trueLuminosity,\n    },\n    limit: {\n      sat: [0, maxSat],\n      lum: [prefer === `lum` ? 0 : minLum, maxLum],\n    },\n  }\n}\n\nexport default specToChannelsFixLimit\n", "import type { Filter, Hex, LuumFix, LuumLimit, LuumSpec } from \"~\"\n\nimport channelsToHex from \"./channelsToHex\"\nimport specToChannels from \"./specToChannelsFixLimit\"\n\ntype SpecToHexFixLimit = (\n  spec: LuumSpec,\n  filter?: Filter\n) => {\n  hex: Hex\n  fix: LuumFix\n  limit: LuumLimit\n}\n\nconst specToHexFixLimit: SpecToHexFixLimit = (\n  { hue, sat, lum, prefer },\n  filter\n) => {\n  const { channels, fix, limit } = specToChannels(\n    {\n      hue,\n      sat,\n      lum,\n      prefer,\n    },\n    filter\n  )\n  const { R, G, B } = channels\n  const hex = channelsToHex({ R, G, B })\n\n  // console.log('--- newHex', hex)\n\n  return { hex, fix, limit }\n}\n\nexport default specToHexFixLimit\n", "import type { Filter, Hex, LuumSpec } from \"~\"\n\nimport specToHexFixLimit from \"./specToHexFixLimit\"\n\nconst specToHex = (\n  { hue, sat, lum, prefer }: LuumSpec,\n  filter?: Filter\n): Hex => {\n  const { hex } = specToHexFixLimit({ hue, sat, lum, prefer }, filter)\n  return hex\n}\n\nexport default specToHex\n", "import type { Degree } from \"~\"\n\nimport { wrapAround } from \"../utils\"\n\ntype NamingPoint = { hue: Degree; name: string }\n\nconst rangeNames: NamingPoint[] = [\n  { hue: 20, name: `red` },\n  { hue: 45, name: `orange` },\n  { hue: 61, name: `yellow` },\n  { hue: 80, name: `citron` },\n  { hue: 100, name: `lime` },\n  { hue: 150, name: `green` },\n  { hue: 180, name: `teal` },\n  { hue: 200, name: `cyan` },\n  { hue: 240, name: `blue` },\n  { hue: 270, name: `indigo` },\n  { hue: 300, name: `violet` },\n  { hue: 330, name: `magenta` },\n  { hue: 350, name: `pink` },\n]\n\nconst identifyHue = (hue: Degree): string => {\n  // console.log('||| hue', hue)\n  const hueWrapped = wrapAround(hue, [0, 360])\n  const { name } =\n    rangeNames.find(({ hue }) => hueWrapped >= hue) || rangeNames[0]\n  /*\n      console.log('||| hue', hue,\n        'is between', namingPointA.hue,\n        'and', namingPointB.hue,\n        'therefore it is named', namingPointA.name)\n      */\n  return name\n}\n\nexport { identifyHue }\n", "import type { ChannelObject, HSL } from \"~\"\n\nimport { hueFromChannels, satFromChannels, lumFromChannels } from \"../solveFor\"\n\nconst channelsToSpec = ({ R, G, B }: ChannelObject): HSL => {\n  const hue = hueFromChannels({ R, G, B })\n  const sat = satFromChannels({ R, G, B })\n  const lum = lumFromChannels({ R, G, B })\n  return { hue, sat, lum }\n}\n\nexport default channelsToSpec\n", "import type { Hex } from \"~\"\n\nconst BASE_16_CHAR_SET = `[a-fA-F0-9]+`\n\nconst miniHexToHex = (miniHex: string): Hex => {\n  const miniHexArray = miniHex.split(``)\n  const hexTemplate = [0, 0, 1, 1, 2, 2]\n  return hexTemplate.map((idx) => miniHexArray[idx]).join(``)\n}\n\nconst normalizeHex = (maybeHex: string): Hex => {\n  const hex = maybeHex.replace(/^#/, ``)\n  const hexIsCorrectLength = hex.length === 6 || hex.length === 3\n  const hexIsCorrectCharSet =\n    hex.match(new RegExp(`^${BASE_16_CHAR_SET}$`)) !== null\n  const hexIsValid = hexIsCorrectLength && hexIsCorrectCharSet\n  if (!hexIsValid) {\n    throw new Error(`${maybeHex} is not a valid hex code`)\n  }\n  if (hex.length === 3) {\n    return miniHexToHex(hex)\n  }\n  return hex\n}\n\nexport default normalizeHex\n", "import type { ChannelObject } from \"~\"\n\nimport normalizeHex from \"./normalizeHex\"\n\nexport default (maybeHex: string): ChannelObject => {\n  const hex = normalizeHex(maybeHex)\n  const getHexcodeChannel = (nameOfChannel: `b` | `g` | `r`) => {\n    switch (nameOfChannel) {\n      /* eslint-disable prettier/prettier */\n      case `r`: return hex.slice(0, 2)\n      case `g`: return hex.slice(2, 4)\n      case `b`: return hex.slice(4, 6)\n      default: throw new Error(`strange channel name`)\n      /* eslint-enable prettier/prettier */\n    }\n  }\n  const rBase10 = parseInt(getHexcodeChannel(`r`), 16)\n  const gBase10 = parseInt(getHexcodeChannel(`g`), 16)\n  const bBase10 = parseInt(getHexcodeChannel(`b`), 16)\n\n  return {\n    R: rBase10,\n    G: gBase10,\n    B: bBase10,\n  }\n}\n", "import type { HSL } from \"~\"\n\nimport channelsToSpec from \"./channelsToSpec\"\nimport hexToChannels from \"./hexToChannels\"\n\nconst hexToSpec = (hex: string): HSL => {\n  const { R, G, B } = hexToChannels(hex)\n  /*\n  console.log('+++ input hex', hex)\n  console.log('||| R', R)\n  console.log('||| G', G)\n  console.log('||| B', B)\n  */\n  const { hue, sat, lum } = channelsToSpec({ R, G, B })\n  return { hue, sat, lum }\n}\n\nexport default hexToSpec\n", "import type { Mixer } from \".\"\n\nconst contrast: Mixer<0 | 1 | 2> = (color, value) => {\n  const { lum } = color\n  switch (value) {\n    case 0:\n      return { ...color, lum: lum > 0.666 ? 0 : 1 }\n    case 1:\n      return { ...color, lum: lum > 0.666 ? 0.05 : 0.95 }\n    case 2:\n      if (lum > 0.75) {\n        return { ...color, lum: lum / 2 }\n      } else if (lum < 0.25) {\n        return { ...color, lum: lum + (1 - lum) / 2 }\n      }\n      return { ...color, lum: lum > 0.666 ? 1 : 0 }\n  }\n}\n\nexport default contrast\n", "import type { Mixer } from \".\"\nimport { wrapAround } from \"..\"\n\nexport const setHue: Mixer<number | ((hue: number) => number)> = (\n  color,\n  value\n) => {\n  const newHue = value instanceof Function ? value(color.hue) : value\n  return { ...color, hue: wrapAround(newHue, [0, 360]) }\n}\n\nexport const trine: Mixer<number> = (color, value) =>\n  setHue(color, (hue) => hue + value * 120)\n\nexport const tetra: Mixer<number> = (color, value) =>\n  setHue(color, (hue) => hue + value * 90)\n\nexport const split: Mixer<number> = (color, value) =>\n  setHue(color, (hue) => hue + value * 150)\n", "import type { Mixer } from \".\"\nimport { clamp } from \"..\"\n\nexport const setLum: Mixer<number | ((lum: number) => number)> = (\n  color,\n  value\n) => {\n  const newLum = value instanceof Function ? value(color.lum) : value\n  return { ...color, lum: clamp(newLum, [0, 1]) }\n}\nexport const tint: Mixer<number> = (color, value) =>\n  setLum(color, (lum) => (lum * 100 + value) / 100)\n\nexport const shade: Mixer<number> = (color, value) =>\n  setLum(color, (lum) => (lum * 100 - value) / 100)\n", "import type { Mixer } from \".\"\nimport { clamp } from \"..\"\n\nexport const setSat: Mixer<number | ((sat: number) => number)> = (\n  color,\n  value\n) => {\n  const newSat = value instanceof Function ? value(color.sat) : value\n  return { ...color, sat: clamp(newSat, [0, 255]) }\n}\nexport const amp: Mixer<number> = (color, value) =>\n  setSat(color, (sat) => sat + value)\n\nexport const mute: Mixer<number> = (color, value) =>\n  setSat(color, (sat) => sat - value)\n", "import type { LuumSpec } from \"~\"\n\nimport { specToHexFixLimit } from \"~/export\"\nimport { hexToSpec } from \"~/import\"\n\nimport contrast from \"./contrast\"\nimport { setHue, split, tetra, trine } from \"./hue\"\nimport { setLum, shade, tint } from \"./lum\"\nimport { setSat, amp, mute } from \"./sat\"\n\nexport type MixerArgs = {\n  hex: string\n  spec: LuumSpec\n  hue: number\n  sat: number\n  lum: number\n  prefer: `lum` | `sat`\n  fix: `lum` | `sat`\n  contrast: 0 | 1 | 2\n  amp: number\n  mute: number\n  tint: number\n  shade: number\n  split: number\n  tetra: number\n  trine: number\n  //cool: number\n  //warm: number\n}\n\nexport type MixerName = keyof MixerArgs\n\nexport type MixTuple<N extends MixerName> = [N, MixerArgs[N]]\n\nexport type Mix = MixTuple<keyof MixerArgs>[]\n\nexport type Mixer<V> = (color: LuumSpec, value: V) => LuumSpec\n\nconst mixers: {\n  [Name in MixerName]: Mixer<MixerArgs[Name]>\n} = {\n  hex: (color, value) => ({ ...color, ...hexToSpec(value) }),\n  spec: (_, value) => ({ ...value }),\n  hue: setHue,\n  sat: setSat,\n  lum: setLum,\n  fix: (color, prefer) => ({\n    ...color,\n    prefer,\n    ...specToHexFixLimit({ ...color, prefer }).fix,\n  }),\n  prefer: (color, prefer) => ({ ...color, prefer }),\n  amp,\n  contrast,\n  mute,\n  tint,\n  shade,\n  split,\n  tetra,\n  trine,\n}\n\nexport default mixers\n", "import type {\n  CssSelector,\n  InteractivePalette,\n  NonInteractivePalette,\n  Palette,\n  Scheme,\n} from \".\"\nimport { mixPalette } from \".\"\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nexport const isInteractivePalette = (\n  palette: Palette<any>\n): palette is InteractivePalette<any> =>\n  !Object.values(palette.attributes)[0].dry\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\nconst indent = (indent = 1, text: string) => ` `.repeat(indent * 2) + text\n\nconst openCssRule = (gen = 0, ...selectors: CssSelector[]): string =>\n  selectors.length > 1\n    ? selectors.reduce<string>((acc, selector, idx) => {\n        const maybeComma = idx === 0 ? `` : `,`\n        return `\\n` + indent(gen, selector) + maybeComma + acc\n      }, ``) + ` {\\n`\n    : `${indent(gen, `${selectors[0]} {\\n`)}`\n\nconst closeCssRule = (gen = 0) => `${indent(gen, `}\\n`)}`\n\nconst createCssProperty = (key: string, value: string, gen = 0) =>\n  indent(1 + gen, `${key}: ${value};\\n`)\n\nexport const paletteToScssDeclarationStatic = (\n  palette: NonInteractivePalette<any>,\n  generation: number\n): string => {\n  let scssDeclaration = ``\n  for (const [attribute, { dry: hex }] of Object.entries(palette.attributes)) {\n    scssDeclaration += createCssProperty(attribute, hex, generation)\n  }\n  return scssDeclaration\n}\n\nexport const paletteToScssDeclarationInteractive = (\n  palette: InteractivePalette<any>,\n  gen: number\n): string => {\n  let declaration = ``\n  const stateDeclarations = {\n    hover: openCssRule(gen + 1, `&:hover`, `&:focus`, `&:focus-within`),\n    active: openCssRule(gen + 1, `&:active`, `&.active`),\n    disabled: openCssRule(gen + 1, `&:disabled`, `&.disabled`),\n  }\n  for (const [key, { base, hover, active, disabled }] of Object.entries(\n    palette.attributes\n  )) {\n    declaration += createCssProperty(key, base.dry, gen)\n    stateDeclarations.hover += createCssProperty(key, hover.dry, gen + 1)\n    stateDeclarations.active += createCssProperty(key, active.dry, gen + 1)\n    stateDeclarations.disabled += createCssProperty(key, disabled.dry, gen + 1)\n  }\n  stateDeclarations.hover += closeCssRule(gen + 1)\n  stateDeclarations.active += closeCssRule(gen + 1)\n  stateDeclarations.disabled += closeCssRule(gen + 1)\n  declaration += stateDeclarations.hover\n  declaration += stateDeclarations.active\n  declaration += stateDeclarations.disabled\n  return declaration\n}\n\nexport const paletteToScssDeclaration = <T extends Scheme>(\n  palette: Palette<T>,\n  generation: number\n): string =>\n  isInteractivePalette(palette)\n    ? paletteToScssDeclarationInteractive(palette, generation)\n    : paletteToScssDeclarationStatic(palette, generation)\n\nexport const nestChildRules = (\n  palette: Palette<any>,\n  generation: number\n): string => {\n  let nestedRules = ``\n  if (palette.children) {\n    for (const child of Object.entries(palette.children)) {\n      const [selector, childPalette] = child as [CssSelector, Palette<any>]\n      nestedRules += paletteToScssRule(selector, childPalette, generation + 1)\n    }\n  }\n  return nestedRules\n}\n\nexport const paletteToScssRule = (\n  selector: CssSelector,\n  palette: Palette<any>,\n  generation = 0\n): string => {\n  let scssBlock = openCssRule(generation, selector)\n  scssBlock += paletteToScssDeclaration(palette, generation)\n  scssBlock += nestChildRules(palette, generation)\n  scssBlock += closeCssRule(generation)\n  return scssBlock\n}\n\nexport type SchemeToScssRule = (selector: CssSelector, scheme: Scheme) => string\n\nexport const schemeToScssRule: SchemeToScssRule = (selector, scheme) => {\n  const palette = mixPalette(scheme)\n  const scss = paletteToScssRule(selector, palette)\n  return scss\n}\n", "import type { LuumSpec } from \"~\"\n\nexport const defaultSpec: LuumSpec = {\n  hue: 0,\n  lum: 0,\n  sat: 0,\n  prefer: `lum`,\n}\n", "const mapObject = <KeyedObj, I, O>(\n  obj: { [K in keyof KeyedObj]: I },\n  fn: (val: I, key: keyof KeyedObj) => O\n): { [K in keyof KeyedObj]: O } => {\n  const newObj = {} as { [K in keyof KeyedObj]: O }\n  const entries = Object.entries(obj) as [keyof KeyedObj, I][]\n  entries.forEach(([key, val]) => {\n    newObj[key] = fn(val, key)\n  })\n  return newObj\n}\n\nexport default mapObject\n", "import type { Filter, LuumSpec } from \"~\"\n\nimport { unfiltered } from \"~/constants/filters\"\nimport { defaultSpec } from \"~/constants/spec\"\nimport { specToHex } from \"~/export\"\nimport type { Mix, Mixer } from \"~/mixers\"\nimport mixers from \"~/mixers\"\nimport mapObject from \"~/utils/mapObject\"\n\nimport type {\n  Swatch,\n  InteractivePalette,\n  InteractiveScheme,\n  InteractiveSwatch,\n  InteractiveMix,\n  Scheme,\n  NonInteractiveScheme,\n  NonInteractivePalette,\n} from \".\"\n\nexport const isInteractiveSwatch = (\n  swatch: InteractiveSwatch | Swatch | undefined\n): swatch is InteractiveSwatch => {\n  if (swatch === undefined) return false\n  return Boolean((swatch as InteractiveSwatch).base)\n}\n\ntype MixNewSpec = (spec: LuumSpec, mix: Mix) => LuumSpec\n\nexport const mixNewSpec: MixNewSpec = (spec, mix) =>\n  mix.reduce<LuumSpec>((currentColor, [name, value]) => {\n    const mixer = mixers[name] as Mixer<typeof value>\n    return mixer(currentColor, value)\n  }, spec)\n\ntype MixNewSwatch = (spec: LuumSpec, mix: Mix, filter?: Filter) => Swatch\n\nexport const mixNewSwatch: MixNewSwatch = (spec, mix, filter) => {\n  const wet = mixNewSpec(spec, mix)\n  const dry = specToHex(wet, filter)\n  return { wet, dry }\n}\n\ntype MixPaletteStatic = <S extends NonInteractiveScheme>(\n  scheme: S,\n  parent?: {\n    filter: Filter\n    attributes: Record<string, InteractiveSwatch> | Record<string, Swatch>\n  }\n) => NonInteractivePalette<S>\n\nexport const mixPaletteStatic: MixPaletteStatic = (scheme, parent) => {\n  const filter = scheme.filter || parent?.filter || unfiltered\n  const rootSpec = mixNewSpec(defaultSpec, scheme.root || [])\n\n  const paletteAttributes = mapObject(scheme.attributes, (mix: Mix, key) => {\n    const parentAttribute = parent?.attributes[key]\n    const startingPoint = isInteractiveSwatch(parentAttribute)\n      ? parentAttribute.base.wet\n      : parentAttribute?.wet || rootSpec\n\n    console.log(parentAttribute)\n    console.log(startingPoint)\n    return mixNewSwatch(startingPoint, mix, filter)\n  }) as Record<keyof typeof scheme.attributes, Swatch>\n\n  const palette: NonInteractivePalette<typeof scheme> = {\n    attributes: paletteAttributes as NonInteractivePalette<\n      typeof scheme\n    >[`attributes`],\n  }\n\n  if (scheme.children) {\n    palette.children = mapObject(scheme.children, (child: Scheme) =>\n      mixPalette(child, { filter, attributes: paletteAttributes })\n    ) as NonInteractivePalette<typeof scheme>[`children`]\n  }\n\n  return palette\n}\n\ntype MixPaletteInteractive = <S extends InteractiveScheme>(\n  scheme: S,\n  parent?: {\n    filter: Filter\n    attributes: Record<string, InteractiveSwatch> | Record<string, Swatch>\n  }\n) => InteractivePalette<S>\n\nexport const mixPaletteInteractive: MixPaletteInteractive = (scheme, parent) => {\n  const filter = scheme.filter || parent?.filter || unfiltered\n  const rootSpec = mixNewSpec(defaultSpec, scheme.root || [])\n\n  const baseSwatches = mapObject(\n    scheme.attributes,\n    (attribute: InteractiveMix, key) => {\n      const parentAttribute = parent?.attributes[key]\n      const startingPoint = isInteractiveSwatch(parentAttribute)\n        ? parentAttribute.base.wet\n        : parentAttribute?.wet || rootSpec\n      return mixNewSwatch(startingPoint, attribute.base, filter)\n    }\n  ) as Record<keyof typeof scheme.attributes, Swatch>\n\n  const paletteAttributes = mapObject(\n    scheme.attributes,\n    (attribute: InteractiveMix, attributeKey) =>\n      mapObject(attribute, (state: Mix, stateKey) => {\n        if (stateKey === `base`) {\n          return baseSwatches[attributeKey]\n        }\n        return mixNewSwatch(baseSwatches[attributeKey].wet, state, filter)\n      })\n  ) as InteractivePalette<typeof scheme>[`attributes`]\n\n  const palette: InteractivePalette<typeof scheme> = {\n    attributes: paletteAttributes,\n  }\n\n  if (scheme.children) {\n    palette.children = mapObject(scheme.children, (child: Scheme) =>\n      mixPalette(child, { filter, attributes: paletteAttributes })\n    ) as InteractivePalette<typeof scheme>[`children`]\n  }\n\n  return palette\n}\n\nexport const isInteractiveScheme = (scheme: Scheme): scheme is InteractiveScheme =>\n  !Array.isArray(Object.values(scheme.attributes)[0])\n\ntype MixPalette = <S extends Scheme>(\n  scheme: S,\n  parent?: {\n    filter: Filter\n    attributes: Record<string, InteractiveSwatch> | Record<string, Swatch>\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n) => InteractivePalette<any> | NonInteractivePalette<any>\n\nexport const mixPalette: MixPalette = (scheme, parent) =>\n  isInteractiveScheme(scheme)\n    ? mixPaletteInteractive(scheme, parent)\n    : mixPaletteStatic(scheme, parent)\n"],
  "mappings": "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",
  "names": []
}
